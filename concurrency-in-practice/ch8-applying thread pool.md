
## 反常识卡——任务与执行策略之间的隐性耦合
- 常识：Executor框架可以将任务的提交与任务的执行策略解耦开来。
- 反常识：其实这种说法多少有点言过其实。虽然Executor框架为制定和修改执行策略提供了很大的灵活性，但并非所有的任务都适用于所有的执行策略。**有些类型的任务需要明确地指定执行策略**。
- 例子：
	- 依赖性任务：大多数行为正确的任务都是独立的，**他们不依赖于其他任务的执行顺序、执行结果或其他效果**，当在线程池中独立执行时，可以随意地改变线程池的大小和配置，这些修改只会对性能产生影响。**如果提交给线程池的任务需要依赖其他的任务，那么就会隐含地给执行策略带来约束，此时必须小心地维持这些执行策略以避免产生活跃性问题。**
	- 使用线程封闭机制的任务：使用线程封闭机制的任务要求其执行所在的Executor是单线程的。如果将Executor从单线程环境改为线程池环境，那么将会失去线程安全性。
	- 对响应时间敏感的任务：如果将一个运行时间较长的任务提交到单线程的Executor中，或者将多个运行时间较长的任务提交到一个只包含少量线程的线程池中，那么将降低由该Executor管理的服务的响应性。
	- 使用ThreadLocal的任务：ThreadLocal使每个线程都可以拥有某个变量的一个私有“版本”。**只有当线程本地值的生命周期受限于任务的生命周期时，在线程池的线程中使用ThreadLocal才有意义，而在线程池的线程中不应该用ThreadLocal在任务之间传递值**。
	- **只有当任务都是同类型的并且相互独立时，线程池的性能才能达到最佳**。