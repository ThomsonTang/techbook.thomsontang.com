
## 反常识卡——任务与执行策略之间的隐性耦合
- 常识：Executor框架可以将任务的提交与任务的执行策略解耦开来。
- 反常识：其实这种说法多少有点言过其实。虽然Executor框架为制定和修改执行策略提供了很大的灵活性，但并非所有的任务都适用于所有的执行策略。**有些类型的任务需要明确地指定执行策略**。
- 例子：
	- 依赖性任务：大多数行为正确的任务都是独立的，**他们不依赖于其他任务的执行顺序、执行结果或其他效果**，当在线程池中独立执行时，可以随意地改变线程池的大小和配置，这些修改只会对性能产生影响。**如果提交给线程池的任务需要依赖其他的任务，那么就会隐含地给执行策略带来约束，此时必须小心地维持这些执行策略以避免产生活跃性问题。**
	- 使用线程封闭机制的任务：使用线程封闭机制的任务要求其执行所在的Executor是单线程的。如果将Executor从单线程环境改为线程池环境，那么将会失去线程安全性。
	- 对响应时间敏感的任务：如果将一个运行时间较长的任务提交到单线程的Executor中，或者将多个运行时间较长的任务提交到一个只包含少量线程的线程池中，那么将降低由该Executor管理的服务的响应性。
	- 使用ThreadLocal的任务：ThreadLocal使每个线程都可以拥有某个变量的一个私有“版本”。**只有当线程本地值的生命周期受限于任务的生命周期时，在线程池的线程中使用ThreadLocal才有意义，而在线程池的线程中不应该用ThreadLocal在任务之间传递值**。
	- **只有当任务都是同类型的并且相互独立时，线程池的性能才能达到最佳**。
	- 运行时间较长的任务，最好限定任务等待资源的时间，而不要无限制的等待。

## 技巧卡——设置线程池的大小
- 在实际编程中，通常不会固定线程池的大小，而是通过某种配置机制来提供，或者根据`Runtime.availableProcessors`来动态计算。
- 要像正确地设置线程池的大小，必须分析计算环境、资源预算和任务的特性：
	- 部署的系统中有多少个CPU？
	- 多大的内存？
	- 任务是计算密集型、I/O密集型还是二者皆可？
	- 是否需要像JDBC连接一样的稀缺资源？
- 如果需要执行不同类别的任务，而且任务之间的行为相差很大，那么应该考虑使用多个线程池，从而使每个线程池可以根据各自的工作负载来调整。

## 术语卡——线程的创建与销毁
- 术语：基本大小（Core Pool Size）、最大大小（Maximum Pool Size）、存活时间
- 印象：线程池的基本大小、最大大小以及存活时间等因素共同负责线程的创建与销毁。
	- 基本大小：也就是线程池的目标大小，即在没有任务执行时线程池的大小，**并且只有在工作队列满了的情况下才会创建超出这个数量的线程**。
	- 最大大小：表示可同时活动的线程数量的上限。
	- 存活时间：当某个线程的空闲时间超过了存活时间，那么将会被标记为可回收的，并且当线程池的当前大小超过了基本大小时，这个线程将会被终止。
- 例子：
	- `newFixedThreadPool`工厂方法将线程池的基本大小和最大大小设置为参数指定的值，而且创建的线程不会超时。
	- `newCachedThreadPool`工厂方法将线程池的最大大小设置为`Integer.MAX_VALUE`，而将基本大小设置为零，并将超时设置为1分钟。这种方法创建出来的线程池可以被无线扩展，并且当需求降低时会自动收缩。
		> 对于Executor，`newCachedThreadPool`工厂方法是一个很好的默认选择，它能提供比固定大小的线程池更好的排队性能。

## 术语卡——饱和策略
- 术语：饱和策略
- 印象：饱和策略在有界队列被填满后开始发挥作用。`ThreadPoolExecutor`的饱和策略可以通过调用`setRejectedExecutionHandler`来修改。JDK提供了几种不同的`RejectedExecutionHandler`实现，每种实现都包含有不同的饱和策略：
	- AbortPolicy
	- CallerRunsPolicy
	- DiscardPolicy
	- DiscardOldestPolicy
- 例子：
	- 中止（Abort）策略是默认的饱和策略。该策略将抛出`RejectedExecutionException`，调用者可以捕获这个异常，然后根据自己的需求编写处理代码。
	- 抛弃策略：新提交的任务无法保存到队列中等待执行，就会抛弃该任务。
	- 抛弃最旧的策略：抛弃的是下一个将要执行的任务。**这个策略最好不要和优先队列一起使用**。
	- 调用者运行策略：该策略是一种协调机制，既不会抛弃任务，也不会抛出异常，而是将某些任务退回到调用者，从而降低新任务的流量。比如主线程调用了`execute`方法，那么当有新的任务无法提交时，就会退回到主线程，由主线程来执行。因为执行任务通常需要一定的时间，所以在此时间内，主线程不会再提交任务，这使得工作线程有更多的时间来处理完成已经提交的任务。