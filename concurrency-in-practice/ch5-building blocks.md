
## 技巧卡
> 在实践中，**委托**是创建线程安全类的一种非常有效的策略：**只需要让现有的线程安全的类来管理所有的状态即可**。java平台本身提供了丰富的并发构建模块，比如常见的线程安全的集合，能够协调多个线程相互协作的同步工具类等。

## 术语卡——同步集合
- 术语：Synchronized Collections
- 印象：诸如`Vector`、`Hashtable`之类的比较「古老」的java同步集合类。这些同步的包装类都是通过`Collections.synchronizedXXX`工厂方法来创建的。**这些类是通过封装他们的状态并且同步每一个公共方法来实现同步的，因此每次只能有一个线程访问集合的状态**。
- 例子：
	- `Vector`
	- `Hashtable`

## 反常识卡—— Problems with Synchronized Collections
- 常识：同步集合类是线程安全。
- 反常识：
	- 虽然同步集合类是线程安全的，但是有时候还是需要额外的客户端加锁来保护复合操作。集合类中常见的复合操作包括：迭代、获取下一个元素以及有条件的操作，例如：先判断有没有元素，没有再添加。**在同步集合类中，这些复合操作在没有客户端加锁的情况下是线程安全的，但是当其他线程并发的修改集合类是，可能会出现与预期不一致的结果**。
	- 虽然加锁可以防止迭代器抛出`ConcurrentModificationException`，但前提是需要在所有对共享容器进行迭代的地方加锁，包括那些隐式的地方。
	- 同步集合类是**通过将所有的对容器状态的访问串行化，来实现线程安全性的**。这种方法的代价的是并发性严重降低，多线程访问容器时，吞吐量严重降低。
- 例子：
	- Compound Actions on a `Vector` that may Produce Confusing Results
		[CompoundActionOnVector.java][1]
	- Iterators and `ConcurrentModificationException`：循环遍历同步集合对象时，如果有其他线程也在同时操作这个集合对象，那么就有可能引发`ConcurrentModificationException`。
	- Hidden Iterators: 
		- 例如，某些同步集合类的`toString()`方法内部实际上执行了迭代遍历
		- 容器的`hashCode()`和`equals()`等方法也会间接地执行迭代操作。
		- 同样，`containsAll()`、`removeAll()`、`retainAll()`等，以及把容器作为参数的构造函数，都会对容器进行迭代
		所有这些间接操作都有可能抛出`ConcurrentModificationException`。

## 术语卡——并发容器
- 术语： 并发容器（Concurrent Collections）
- 印象：
	- 并发容器类是专门为多个线程并发访问设计的。
	- 并发容器类不仅可以替代同步容器类，而且具有更好的并发特性，性能也要比同步容器好很多。
- 例子：
	- `ConcurrentHashMap`
	- `CopyOnWriteArrayList`
	- Java 5.0 新增的`Queue`和`BlockingQueue`:
		- Queue用来临时保存一组待处理的元素，Queue的操作不会阻塞，如果队列为空，那么获取元素的操作将返回空值
		- BlockingQueue扩展了Queue，增加了可阻塞的插入和获取操作。如果队列为空，获取元素的操作将一直阻塞，直到队列中出现一个可用的元素；如果队列已满（有界队列），那么插入元素的操作将一直阻塞，直到队列中出现可用的空间。

## 术语卡——ConcurrentHashMap
- 术语：ConcurrentHashMap
- 印象：
	- 我们知道同步容器类在执行每一个操作期间都会持有一个锁，这通常会导致并发效率很低，所以ConcurrentHashMap采用了一种完全不同的加锁策略，称之为**分段锁**，这是一种粒度更精细的加锁机制。这种机制下，任意多的读线程都可以并发访问Map，读取操作的线程和写入操作的线程也可以并发访问Map，甚至一定数量的写线程都可以并发修改Map。
	- ConcurrentHashMap提供的迭代器不会抛出`ConcurrentModificationException`，因此在迭代过程中不需要加锁。
	- 由于ConcurrentHashMap不能被加锁来执行独占访问，所以我们无法使用客户端加锁来创建新的原子操作。

## 术语卡——CopyOnWriteArrayList
- 术语：CopyOnWriteArrayList，CopyOnWriteArraySet
- 印象：
	- 用于代替同步list（或同步set），相对而言它提供了更好的并发性能，而且在迭代期间不需要对容器进行加锁或复制。
	- 这种「写入时复制」的容器只要能够正确的发布一个事实上不可变的对象，那么在访问容器的时候就不需要额外的同步手段，从而保证了它的线程安全性。
	- 同时，在迭代的过程中，也不会抛出`ConcurrentModificationException`
	- 由于每次修改容器时都会复制底层数组，所以当容器规模较大时，会导致一定的开销。因此我们应当在**迭代操作远远大于修改操作时才考虑使用「写入时复制」的容器**。

## 术语卡——工作密取
- 术语：工作密取（Work Stealing）
- 印象：
	- JDK1.6新增的两种容器类型`Deque`和`BlockingDeque`分别对 `Queue`和`BlockingQueue`进行了扩展，`Deque`是一个双端队列，实现了在队列头和队列尾的高效插入和删除。
	- 阻塞队列适用于**生产者——消费者**模式，双端队列则适用于**工作密取(Work Stealing)**。在Producer-Consumer模式中，所有消费者有一个共享的消费队列，而在工作密取的设计的中，每个消费者都有各自的双端队列。如果一个消费者完成了自己双端队列中的所有工作，那么它可以从其它消费者的双端队列的末尾秘密地获取工作。
	- 密取工作模式比传统的 Producer-Consumer 模式具有更高的可伸缩性。这是因为工作者线程不会在单个共享队列上发生竞争，大部分时候它们都是在自己的双端队列中获取任务，即使访问其他队列时，也是从队列的尾部获取任务，而不是头部，这样更进一步的降低了竞争程度。
	- 工作密取非常适合于**即是消费者又是生产者的问题——当执行某个工作时可能导致出现更多的工作**。
- 例子：
	- 网页爬虫程序处理一个页面时，通常会发现有更多的页面需要处理。
	- 搜索图算法。

## 术语卡——同步工具类
- 术语：synchronizers
- 印象：
	- 同步工具类可以是任何一个对象，只要它能根据自身的状态来协调线程的控制流。
	- 同步工具类包含有一些特定的结构化属性：
		- 它们封装了一些状态；
		- 这些状态决定了执行同步工具类的线程是继续执行还是等待
		- 提供了一些对状态进行操作的方法，使得同步工具类能够进入到预期的状态
- 例子：
	- 阻塞队列：一种独特的类，既能作为保存对象的容器，又能协调生产者和消费者等线程之间的控制流。
	- 闭锁
	- 信号量
	- 栅栏

## 术语卡——闭锁
- 术语：闭锁（Latch）
- 印象：
	- 闭锁可以延迟线程的执行进度直到达到其终止状态。闭锁相当于一扇门，在闭锁达到终止状态前，门是关闭的，没有任何线程可以通过，只有当达到结束状态时，门才会打开，并允许所有的线程通过，且闭锁的状态将不会再改变，也就是说这扇门将一直是打开的状态。
	- 闭锁可以确保某些活动直到其他活动执行完成后才能继续执行：
		- 确保某个计算在其需要的所有资源都被初始化之后才继续执行。
		- 确保某个服务在其依赖的所有其他服务都已经启动之后才启动。
		- 等待直到某个操作的所有参与者都就绪再继续执行。
- 例子：
	- `CountDownLatch`是一种灵活的闭锁实现。
	- 闭锁状态包括一个计数器，该计数器的初始化值表示需要等待的事件数量。`countDown`方法递减计数器，表示一个事件已经发生了，而`await`方法等待计数器达到零，这就意味着所有需要等待的事件都已经发生了。如果计数器的值非零，那么`await`方法会一直阻塞直到计数器为零，或者等待中的线程中断，或者等待超时。

## 术语卡——FutureTask
- 术语：Future
- 印象：
	- Future语义表示一种抽象的可生成结果的计算。FutureTask实现了Future语义。
	- FutureTask也可以用作闭锁，它所表示的计算是通过`Callbale`来实现的，相当于一种可生成结果的`Runnable`。
	- FutureTask可以处于以下三种状态：
		- 等待运行
		- 正在运行
		- 运行完成
	- `Future.get`的行为取决于任务的状态，如果任务已经完成，那么`get`将立即返回结果，否则`get`将阻塞直到任务进入完成状态，然后返回结果或者抛出异常。
	- FutureTask将计算结果从执行计算的线程传递到获取这个结果的线程，FutureTask的规范会保证这种传递过程能实现结果的安全发布。
	- FutureTask在Executor框架中表示异步任务，此外还可以表示一些时间较长的计算，这些计算可以在使用计算结果之前启动。
- 例子：使用FutureTask来提前加载稍后需要的数据

## 术语卡——信号量
- 术语：信号量（Semaphore）
- 印象：
	- 计数信号量（Counting Semaphore) 用来控制同时访问某个特定资源的操作数量，或者同时执行某个特定操作的数量。计数信号量还可以用来实现某种资源池，或者对容器施加边界。
	- Semaphore中管理着一组虚拟的许可，许可的初始数量可以通过构造函数来指定，在执行操作时如果还有剩余的许可，那么就获得许可，并在使用以后释放许可。如果没有许可，那么`acquire()`方法将阻塞直到有许可，或者直到被中断或者操作超时。`release()`方法将返回一个许可给信号量。
	- 二值信号量是一种简化计数信号量，即初始值为1的Semaphore。二值信号量可以用做互斥体（mutex），并具备不可重入的加锁语义：谁拥有了这个唯一的许可，谁就拥有了互斥锁。
- 例子：
	- Semaphore可以用于实现资源池，例如数据库连接池。
	- 可以使用Semaphore将任何一种容器变成有界阻塞容器。

## 术语卡——栅栏
- 术语：栅栏（Barrier）
- 印象：
	- 闭锁是一次性对象，一旦进入终止状态，就不能被重置。
	- 栅栏类似于闭锁，它能阻塞一组线程直到某个事件发生。栅栏与闭锁的关键区别在于，所有线程必须同时到达栅栏位置，才能继续执行。闭锁用于等待事件，而栅栏用于等待其他线程。
	- `CyclicBarrier`可以使一定数量的参与者反复地在栅栏位置汇集，它在并行迭代算法中非常有用。这种算法通常将一个问题拆分成一系列相互独立的子问题。
	- 当线程到达栅栏位置时，这个方法将阻塞直到所有线程都到达栅栏位置。如果所有线程都到达了栅栏位置，那么栅栏将打开，此时所有线程都被释放，而栅栏将被重置以便下次使用。
	- 如果对await的调用超时，或者await阻塞的线程被中断，那么栅栏就被认为是打破了，所有阻塞的await调用都将终止并抛出`BrokenBarrierException`。
- 例子：
	- 栅栏用于实现一些协议，例如几个家庭决定在某个地方汇合。



[1]:	https://gist.github.com/ThomsonTang/4751d33d55e6c8b819f885bf06ecd3b0