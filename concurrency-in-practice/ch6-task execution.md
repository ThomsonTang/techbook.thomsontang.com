
## 术语卡——任务
- 术语：任务（task）
- 印象：任务通常是一些抽象的且离散的工作单元，通过把应用程序的工作分解到多个任务中，可以简化程序的组织结构，提供一种自然的事务边界来优化错误恢复过程，以及提供一种自然的并行工作结构来提升并发性。
- 例子：
	- 当围绕「任务执行」来设计应用程序结构时，第一步就是要**找出清晰的任务边界**。
	- 理想状态下，**各个任务之间是相互独立的，任务并不依赖于其他任务的状态、结果或边界效应**。独立性有助于实现并发。
	- 任务可以被串行地执行（例如：`SingleThreadWebServer`），但这样性能非常糟糕。
	- 显示的为任务创建线程：任务处理过程从主线程中分离出来；任务可以并行处理，从而能同时服务多个请求；任务处理代码必须是线程安全的。
	- 无限制创建线程的不足：
		- 线程生命周期的开销非常高，线程的创建和销毁是有代价的
		- 资源消耗，如果已经拥有足够多的线程使得CPU处于忙碌状态，那么再创建更多的线程反而会降低性能。
		- 稳定性：在可创建线程的数量上存在一个限制。这个限制值将随着平台的不同而不同，并且受到**JVM启动参数、Thread构造函数中请求栈的大小、以及底层操作系统对线程的限制**等多个因素的影响。

## 术语卡——Executor
- 术语：Executor
- 印象：
	- Java类库中，任务执行的主要抽象不是`Thread`，而是`Executor`。
	- `Exectuor`虽然是个简单的接口，但是它能支持多种不同类型的任务执行策略。
	- `Executor`将**任务的提交过程和执行过程**解耦开来，并用`Runnable`来表示任务。
	- `Executor`的实现还提供了对生命周期的支持，以及统计信息收集、应用程序管理机制和性能监视等机制。
	- `Executor`基于生产者——消费者模式，提交任务的操作相当于生产者，执行任务的线程相当于消费者。
- 例子：
	- 参考书中 WebServer 的示例，`TaskExecutionWebServer.java`
	- 每当看到下面形式的代码就应该考虑使用`Executor`代替`Thread`:
		```java
		new Thread(runnable).start();
		```

## 术语卡——线程池
- 术语：Thread Pool
- 印象：
	- 管理一组同构工作线程的资源池。线程池是与工作队列密切相关的，工作队列中保存了所有等待执行的任务，工作者线程则是从工作队列中获取一个任务，执行任务，然后返回线程池并等待下一个任务。
	- 在线程池中执行任务比为每个任务分配一个线程要有更多优势：线程已经创建好了，不用每次新建线程，有任务了直接给工作者线程执行即可，还可以重用已有的线程；根据系统的条件等，适当的调整线程池的大小等参数，可以最大的利用系统资源。
- 例子：Java类库中可以通过`Executors`中的静态工厂方法来创建一个线程池：
	- `newFixedThreadPool`：创建固定长度的线程池，每提交一个任务就创建一个线程，直到达到线程池的最大数量，此时线程池的规模将不再变化。如果某个线程因exception结束，那么线程池会补充一个新的线程。
	- `newCachedThreadPool`：创建可缓存的线程池，如果线程池的当前规模超过了处理请求时，那么将回收空闲的线程，而当需求增加时，则可以添加新的线程，线程池的规模不存在任何限制。
	- `newSingleThreadExecutor`：一个单线程的Executor，它创建单个工作者线程来执行任务，如果该线程异常结束，会创建另一个线程来替代。它可以确保任务按队列中的顺序串行执行。