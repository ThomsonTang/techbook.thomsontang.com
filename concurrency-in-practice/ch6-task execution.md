
## 术语卡——任务
- 术语：任务（task）
- 印象：任务通常是一些抽象的且离散的工作单元，通过把应用程序的工作分解到多个任务中，可以简化程序的组织结构，提供一种自然的事务边界来优化错误恢复过程，以及提供一种自然的并行工作结构来提升并发性。
- 例子：
	- 当围绕「任务执行」来设计应用程序结构时，第一步就是要**找出清晰的任务边界**。
	- 理想状态下，**各个任务之间是相互独立的，任务并不依赖于其他任务的状态、结果或边界效应**。独立性有助于实现并发。
	- 任务可以被串行地执行（例如：`SingleThreadWebServer`），但这样性能非常糟糕。
	- 显示的为任务创建线程：任务处理过程从主线程中分离出来；任务可以并行处理，从而能同时服务多个请求；任务处理代码必须是线程安全的。
	- 无限制创建线程的不足：
		- 线程生命周期的开销非常高，线程的创建和销毁是有代价的
		- 资源消耗，如果已经拥有足够多的线程使得CPU处于忙碌状态，那么再创建更多的线程反而会降低性能。
		- 稳定性：在可创建线程的数量上存在一个限制。这个限制值将随着平台的不同而不同，并且受到**JVM启动参数、Thread构造函数中请求栈的大小、以及底层操作系统对线程的限制**等多个因素的影响。

## 术语卡——Executor
- 术语：Executor
- 印象：
	- Java类库中，任务执行的主要抽象不是`Thread`，而是`Executor`。
	- `Exectuor`虽然是个简单的接口，但是它能支持多种不同类型的任务执行策略。
	- `Executor`将**任务的提交过程和执行过程**解耦开来，并用`Runnable`来表示任务。
	- `Executor`的实现还提供了对生命周期的支持，以及统计信息收集、应用程序管理机制和性能监视等机制。
	- `Executor`基于生产者——消费者模式，提交任务的操作相当于生产者，执行任务的线程相当于消费者。
- 例子：
	- 参考书中 WebServer 的示例，`TaskExecutionWebServer.java`
	- 每当看到下面形式的代码就应该考虑使用`Executor`代替`Thread`:
		```java
		new Thread(runnable).start();
		```

## 术语卡——线程池
- 术语：Thread Pool
- 印象：
	- 管理一组同构工作线程的资源池。线程池是与工作队列密切相关的，工作队列中保存了所有等待执行的任务，工作者线程则是从工作队列中获取一个任务，执行任务，然后返回线程池并等待下一个任务。
	- 在线程池中执行任务比为每个任务分配一个线程要有更多优势：线程已经创建好了，不用每次新建线程，有任务了直接给工作者线程执行即可，还可以重用已有的线程；根据系统的条件等，适当的调整线程池的大小等参数，可以最大的利用系统资源。
- 例子：Java类库中可以通过`Executors`中的静态工厂方法来创建一个线程池：
	- `newFixedThreadPool`：创建固定长度的线程池，每提交一个任务就创建一个线程，直到达到线程池的最大数量，此时线程池的规模将不再变化。如果某个线程因exception结束，那么线程池会补充一个新的线程。
	- `newCachedThreadPool`：创建可缓存的线程池，如果线程池的当前规模超过了处理请求时，那么将回收空闲的线程，而当需求增加时，则可以添加新的线程，线程池的规模不存在任何限制。
	- `newSingleThreadExecutor`：一个单线程的Executor，它创建单个工作者线程来执行任务，如果该线程异常结束，会创建另一个线程来替代。它可以确保任务按队列中的顺序串行执行。
	- `newScheduledThreadPool`：创建一个固定长度的线程池，而且以延迟或定时的方式来执行任务。

## 术语卡——ExecutorService
- 术语：ExecutorService
- 印象：`ExecutorService`是对`Executor`的扩展，其目的是为了解决执行服务的生命周期，因此其包含了一些用于生命周期管理的方法，同时还有一些用于任务提交的便利方法。
	- `ExecutorService`的生命周期有3种状态：**运行、关闭和已终止**。
	- 在`ExecutorService`关闭后提交的任务将由“拒绝执行处理器(Rejected Execution Handler)”来处理。它会抛弃任务，或者使得`execute`方法抛出一个未检查的`RejectedExecutionException`，等所有任务都完成后，`ExecutorService`将转入终止状态。
- 例子：
	- `shutdown()`
	- `shutdownNow()`
	- `isShutdown()`
	- `isTerminated()`
	- `awaitTermination()`

## 反常识卡
- 常识：`Timer`类负责管理延迟任务以及周期任务。
- 反常识：`Timer`类存在一些缺陷，最好使用`ScheduledThreadPoolExecutor`来代替它。
- 例子：
	- `Timer`类在执行所有定时任务时只会创建一个线程。如果某个任务的执行时间过长，那么将破坏其他TimeTask的定时准确性。举例来说，TimerTaskA 需要每10ms执行一次，TimerTaskB 需要执行40ms，那么TaskA要么在TaskB执行完成以后连续的调用4次，要么彻底丢失4次调用。**线程池能不弥补这个缺陷，它可以提供多个线程来执行延时任务和周期任务**。
	- `Timer`的另一个问题是，如果`TimerTask`抛出了一个未检查异常，那么Timer将表现出糟糕的行为。Timer线程并不捕获异常，因此当`TimerTask`抛出未检查异常时将终止定时线程。这种情况下，Timer也不会恢复线程的执行，而是会错误地认为整个Timer都被取消了。因此，已经被调度但尚未执行的TimerTask将不会再执行，新的任务也不能被调度。

## 术语卡——Callable
- 术语：Callable
- 印象：
	- `Callable`接口可以用来替代`Runnable`接口作为任务的表现形式。通常情况下，在`Executor`框架下我们默认使用`Runnable`来表示要执行的任务，但是`Runnable`有着比较明显的局限性：
		- 没有返回值。当然可以在`run()`方法中将结果写入文件或者是一个共享的数据结构中。
		- `run()`方法不能抛出异常。因此通常都是在`run()`中捕获异常并进行处理。
		`Callable`正好能解决如上的局限性，因此它是一种对任务更好的抽象。
	- `Future`表示一个任务的生命周期，并提供了相应的方法来判断任务是否已经完成或者取消，以及获取任务的结果和取消任务等。
		- `get`方法的行为取决于任务的状态（未开始、执行中、已完成）。如果任务已经完成，`get`会立即返回或者抛出一个异常；如果任务没有完成，`get`会阻塞并直到任务完成。
- 例子：
	- `Runnable`和`Callable`描述的都是抽象的计算任务。这些任务通常都是有范围的，即都有一个明确的起始点，并最终会结束。
	- `Executor`中包含了一些辅助方法能将其他类型的任务封装为一个`Callable`。
	- `Executor`执行的任务有4个生命周期阶段：创建、提交、开始和完成。在`Executor`框架中，已提交但尚未开始的任务可以取消，但对于已经开始执行的任务，在它们能响应中断时才能取消。
	- 可以使用`Callable<Void>`来表示无返回值的任务。
	- `ExecutorService`中的所有`submit`方法都将返回一个`Future`，从而将一个`Runnable`或`Callable`提交给`Executor`，并得到一个`Future`用来获得任务的执行结果或者取消任务。