
## 反常识卡
- 常识：多线程能够最大的提高系统的资源利用率和吞吐量，而且在某些情况下还能简化系统的复杂度。线程通常具有如下几个优点：
	- **Exploiting Multiple Processor**: 现代计算机大多都是多核的，因此作为操作系统基本调度单位的线程能够最大程度的保证计算机的每个核心都能有事可干，从而发挥计算机的多核处理能力。
	- **Simplicity of Modeling**：有了多线程，我们在为某些复杂的系统或者应用建模时，就能将其功能拆分为若干个任务，每个任务可以有独立的线程来完成，最后将结果汇总。我平常使用的许多框架正式利用多线程解决了**请求管理**、**线程创建**、**负载均衡**等不同的细节问题。
	- **Simplified Handling of Asynchronous Events**: 对于异步处理事件来说，多线程能使各个事件之间相互独立，各行其事，而不会出现互相阻塞的情况。

- 反常识：我们除了关心线程带给我们的好处之外，在使用多线程的时候，还要注意它所带来的风险，毕竟多线程编程增加了开发的复杂度。多线程还会带来如下的风险：
	- 安全性问题
	- 活跃性问题
	- 性能问题
- 例子：
	- **Safety Hazards**：线程安全是一个非常复杂的问题，在没有足够同步的情况下，多线程中的操作执行顺序是不可预测的，常常会产生一些奇怪的结果。
		- Non-thread-safe Sequence Generator:

		```java
		@NotThreadSafe
		public class UnsafeSequence{
			private int value;
			
			// Returns a unique value.
			public int getNext() {
				return value++;
			}
		}
		```

		上面的例子的问题主要在于**如果两个线程执行的时机不对，那么在调用 `getNext()` 方法后会得到相同的值**。这种是一种很常见的并发安全问题，称之为**竞态条件（Race Condition）**。在多线程环境下，`getValue()` 是否会返回唯一的值，取决于运行时对线程中操作的交替执行方式，但这并不是我们想要看到的结果。想要多线程程序的行为可以预测，我们就必须对**共享变量**的访问操作进行一定的协同，使得他们不会互相干扰。幸运的是，**Java提供了各种同步机制来协调这种访问**。
		- Thread-safe Sequence Generator:

			```java
			@ThreadSafe
			public class Sequence {
					private int value;
					
					public synchronized int getNext() {
						return value++;
					}
			}
			```

将取值方法 `getNext()` 改为同步方法以后就可以修复之前的线程安全性问题了。

- **Liveness Hazards**: 安全性意味着「永远不要发生糟糕的事情」，而活跃性关注的则是另一个目标「正确的事情最终会发生」。 当一个活动达到某种状态以至于它不能继续往前执行时，就会引发活跃性问题。在串行执行的程序中，常见的一个活跃性问题就是**无限循环**，它导致跟在循环后面的代码无法得到执行的机会。多线程还会带来其他的活跃性问题，例如：**「死锁」、「饥饿」**以及**「活锁」**等。通常，安全性问题在单线程环境下也会存在，但是活跃性则更多的是在多线程环境中出现。

	- **Performance Hazards**: 与活跃性问题密切相关的是**性能问题**。性能问题包括多个方面：
		- 服务时间过长
		- 程序响应不及时
		- 吞吐率过低
		- 资源消耗过高
		- 可伸缩性较差
		- 线程切换引起的开销
		- 同步机制导致一些编译器优化无法进行
- 出处：《Java Concurrency in Practice》第一章

## 反常识卡
- 常识：在日常的开发工作中，开发人员一般都很少在应用程序中显示的创建线程，所以多线程总是被称为Java语言的高级特性，其重要性常常被忽视。
- 反常识：虽然我们很少在应用程序中显示创建线程，但是在开发中使用到的框架、Java图形库或JVM本身都会使用到多线程，所以熟悉多线程及其并发性对Java开发人员来说也是基本要求。
- 例子：如下的这些模块都将在应用程序之外的线程中调用应用程序的代码，因此在整个应用程序中都应考虑线程的安全性。
	- Timer: Timer类可以使某个任务在稍后的深刻运行，或运行一次，或周期性的运行。**引入Timer可能会使串行程序变为并发程序，因为TimerTask将在Timer自己管理的线程中执行**，而不是应用程序的线程中。如果某个TimerTask访问了应用程序中其他线程访问的数据，那么TimerTask和其他类都要采用线程安全的方式来访问该数据。其实要实现这个目标，最简单的方式就是**确保被访问的对象本身是线程安全的**，这样就可以把线程安全性封装在共享对象的内部。
	- Servlet和JSP：Servlet框架用于开发WEB应用程序。通常情况下，用户请求到达后会被一个过滤器链分发到相应的Servlet或JSP处理，每一个Servlet表示一个程序逻辑组件，多个用户可能同时请求同一个Servlet请求。因此，在Servlet规范中，要求Servlet需要是线程安全的。一般多个Servlet会共享一些信息，例如应用程序中的对象（保存在`ServeltContext`）或会话中的对象（保存在`HttpSession`中），由于多个请求可能在不同的线程中同时访问这些对象，所以必须正确的协同这些对象的访问。**Servlet和JSP，以及在ServletContext和HttpSession等容器中保存的Servlet过滤器和对象等，必须是线程安全的**。
	- 远程方法调用（RMI）：远程对象必须注意两个线程安全性问题：**正确地协同在多个对象间共享的状态的访问**以及**对远程对象本身状态的访问（因为同一个对象可能会在多个线程中被同时访问）**。与Servlet相同，RMI对象也需要做好被多个对象同时访问的准备，并且保证他们自身的线程安全性。
- 出处：《Java Concurrency in Practice》第一章

