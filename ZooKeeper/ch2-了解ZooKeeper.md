
## 反常识卡
- 常识：设计一个用于协作需求的服务的方法**往往是提供原语列表，暴露出每个原语的实例化调用方法，并直接控制这些实例**。例如，分布式锁机制组成了一个重要的原语，同时暴露出创建（create）、获取（acquire）和释放（release）三个调用方法。
- 反常识：上述的设计存在重大的缺陷：
	- 设计者必须预先提供一份详尽的原语列表，要么提供API的扩展，以便引入新的原语
	- 以这种方式实现原语的服务使得应用丧失了灵活性。
- 例子：ZooKeeper采用了其他的方式。
	- ZooKeeper并不直接暴露原语，而是暴露了一小部分调用方法组成的类似文件系统的API，以便允许应用实现自己的原语。
	- 我们通常使用**菜谱（recipes）**来表示这些原语的实现。菜谱包括ZooKeeper操作和维护一个小型的数据节点，这些节点被称为`znode`，采用类似于文件系统的层级树状结构进行管理。
	- 主从模式的数据结构示例图:

		![][image-1]

		- 主节点的znode没有数据表示当前还没有选举出主节点
		- `/workers`: 作为父节点，其下每个znode子节点保存了系统中一个可用从节点信息，例如，有一个从节点`foo.com:2181`。
		- `/tasks`: 作为父节点，其下每个znode子节点保存了所有已创建并等待从节点执行的任务的信息
		- `/assign`: 作为父节点，其下的每个znode子节点保存了分配到某个从节点的一个任务信息，当主节点为某个从节点分配了一个任务，就会在`/assign`下增加一个子节点。
	- `znode`节点可能包含有数据，也可能没有。如果一个`znode`节点包含任何数据，那么**数据存储为字节数组（byte array)**。ZooKeeper并不直接提供解析的支持。


## 术语卡
- 术语：`znode`的类型
- 印象：znode共有4种类型：持久的、临时的、持久有序的、临时有序的
- 例子：
	- **持久节点**：只能通过`delete`来进行删除。持久类型的znode保存的数据，即使znode的创建者不再属于应用系统时，数据也可以保存下来而不会丢失。
	- **临时节点**：当创建该znode节点的客户端崩溃或关闭了与ZooKeeper的连接时，这个节点就会被删除。临时节点传达了应用某些方面的信息，仅当创建者的会话有效时这些信息必须有效保存。
			  
		> 因为临时的znode在其创建者的会话过期时被删除，所以我们现在不允许临时节点拥有子节点。未来的版本可能会有新的改动。
	- **有序节点**：一个znode还可以设置为有序节点。一个有序的znode节点被分配唯一一个单调递增的整数，当创建有序节点时，一个序号会被追加到路径之后。例如：`/tasks/task-1`


## 术语卡——【监视与通知】
- 术语：通知机制、监视点
- 印象：
	- 通知：为了替换客户端的轮询问题，ZooKeeper选择了**基于通知的机制**：客户端向ZK注册需要接收通知的ZNode，通过对ZNode设置监视点（watch）来接收通知。
	- 监视点：监视点是一个单次触发的操作，意即监视点会触发一个通知。为了接收多个通知，客户端必须在每次通知后设置一个新的监视点。
- 例子：
	- 通知机制的一个重要保障是，对同一个znode的操作，先向客户端传送通知，然后再对该节点进行变更。


## 术语卡——【版本号】
- 术语：版本号
- 印象：每一个ZNode多有一个版本号，它随着每次数据变化而自增。
- 例子：`setData`和`delete`这两个API在调用时以版本号作为传入参数，只有当传入参数的版本号和服务器上的版本号一致时调用才会成功。当多个ZK客户端对同一个ZNode进行操作时，版本的使用就会显得尤为重要。

## 术语卡——【ZK服务器运行模式】
- 术语：独立模式、仲裁模式
- 印象：
	- 独立模式（standalone）: 有一个单独的服务器，ZooKeeper状态无法复制。
	- 仲裁模式（quorum）：具有一组ZooKeeper服务器，，即ZooKeeper集群，他们之间可以进行状态的复制，并同时服务于客户端的请求。

[image-1]:	https://user-images.githubusercontent.com/980216/28758132-79714ee8-75c5-11e7-921b-98a08d7b55b5.png