
# 反常识卡
- 反常识：在某些场景下，过度的同步会导致性能下降、死锁甚至出现不确定的行为。
- 常识：多线程环境中，要警惕不充分的同步导致的危险，所以尽可能的保证同步。
- 例子：
	- **为了避免活跃性和安全性错误，在同步方法和同步块中，不要将控制权交给客户端**。换句话说，在一个同步块中，不要调用那些被设计成可覆写的方法，或者是那些由客户端以**函数对象**的形式提供的方法。从同步块自己的角度来看，这些方法都是「外来的」。类通常对这种方法一无所知或者没有任何的控制权。具体参看[Java-Review/ObservableSetTest.java][1]这个例子。
		- 在真实的系统中，如果我们在同步代码块中调用**外部方法**，通常会导致许多`死锁`，例如GUI工具包。
		- 幸运的是，通常上述问题（异常和死锁）并非不好解决，我们可以通过将**外部方法的调用移出同步块**来解决。
		- 事实上，还有一个更好的方法可以将外部方法的调用移到同步块之外。这就是JDK1.5提供的**并发集合**中的`CopyOnWriteArrayList`，可以说，它就是为此类问题量身定制的。
	- 通常来讲，你应该尽可能少地在同步块中做过多的处理。只需做如下简单的事情：获取锁、检查共享数据、按需转换，然后释放锁即可。
	- 在多核的世界里，**过度同步的真正成本并不在于为了获取锁而花费的CPU耗时，而是其导致失去了并行化的机会，以及为了实现每个核心保持对内存的一致性这样的强需求而发生的延迟时间**。
	- 过度同步的另一个隐性成本在于**它会限制虚拟机优化代码运行的能力**。
	- 为了达到使用并发的目的，你应该实现一个线程安全的可变的类，并且通过在内部使用同步的方式实现高并发，而不是在外部将整个对象加锁。除此之外，请不要在类的内部做同步处理，而是让客户端在合适的地方去实现外部化的同步机制。在早期的java平台中，有许多类就违反了这些规范。
		- 例如，`StringBuffer`就是一个实现了内部同步的类，为此，JDK1.5专门提供了一个功能与其类似的非同步的`StringBuilder`类，在单线程环境下，我应优先考虑使用`StringBuilder`。
	- 如果一个方法修改了某个静态域，那么你必须要对这个静态域做同步访问，即使此方法仅在单线程环境中使用。让客户端对这种方法实现外部化的同步机制几乎是不可能的，因为不能保证那些不相关的客户端也会做出相同的实现。
	- 总而言之，为了避免死锁和数据损坏，不要在同步块中调用外部的方法。更通常的做法是，尝试限制在同步块中所做的事情的数量。
- 出处：《Effective Java》2nd Edition

[1]:	https://github.com/ThomsonTang/Java-Review/blob/master/effective-java/src/test/java/effective/concurrency/item67/ObservableSetTest.java